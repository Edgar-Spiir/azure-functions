# Azure Functions

This repository is full of custom Azure functions (like AWS Lambda) that I use. Most are Alexa skills, some are daily roundup emails.

## Secrets

This repository uses [git-secret](https://github.com/sobolevn/git-secret) to encrypt `env.yml` files which are used in turn to specify sensitive env values to functions and Docker images. You'll need a GPG key to use git-secret, and you can only decrypt the files if your key has already been added as a trusted user. [Installation instructions are here.](http://git-secret.io/installation)

Usage:

|Command|Description|
|-------|-----------|
|`git secret init`|Initializes git-secret for the repository. Only needs to be done once per project.|
|`git secret tell`|Adds a GPG key to the trusted users list. Use the `-m` flag to add your own key.|
|`git secret add path/to/file`|Adds a file to git secret. This file **must** be ignored by your .gitignore file or else it will be checked in to source control.|
|`git secret hide`|Encrypts all added files and creates new ones with the filename format `filename.extension.secret`. These files **should be added to source control**.|
|`git secret reveal`|Decrypts all added files with their original filename.|

## Deploying

Node functions can be packed with `azure-functions-pack` package, which is *supposed* to speed up their initial startup time. I haven't seen that speed improvement, personally, but it's easy enough to do so the deploy script will pack them before deploying.

C# functions will execute more quickly when they're built as a classlib. Visual Studio tries to auto-generate the function.json and host.json for each function, but it does a pretty poor job of it. For Azure Functions to discover a function, there needs to be a host.json at the top-level, and each function should be one folder down with a function.json.

However, when Visual Studio builds the functions it puts that function.json in `ProjectName/bin/{Debug|Release}/{Framework}/ProjectName/function.json`, completely out in left field where Azure will not discover it. To make the functions discoverable, we can just ignore Visual Studio's generated function.json and instead modify the default function.json for each function, adding a `scriptFile` and `entryPoint`:

```json
{
  "disabled": false,
  "bindings": [
    {
      "authLevel": "function",
      "name": "req",
      "type": "httpTrigger",
      "direction": "in"
    },
    {
      "name": "$return",
      "type": "http",
      "direction": "out"
    }
  ],
  "scriptFile": "./bin/Release/net461/BeardBrosTrivia.dll",
  "entryPoint": "BeardBrosTrivia.TriviaBoi.Run"
}
```

In a C# function, `entryPoint` should be the fully-qualified name for your function's entry method, e.g. `Namespace.Class.MethodName`.

When deploying Node functions, all you need is the `host.json` and `local.settings.json` files along with the `.funcpack` folder generated by `azure-functions-pack`.

When deploying C# functions, you need the generated DLL file *plus* all dependency DLLs. That makes for a big deploy file, so at some point I need to revisit the `deploy.sh` script and have it only upload generated DLL files for C# functions, then add a Kudu post-deployment script that will run `dotnet restore` on the server.